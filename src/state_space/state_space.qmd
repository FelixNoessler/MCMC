---
title: "State space model"
engine: julia
bibliography: ../lit.bib
format:
    html:
        toc: true
        number-sections: true
---


```{dot}
//| fig-width: 7
//| label: fig-hmm
//| fig-cap: "Forward algorithm for a hidden markov model."
digraph HMM {
    node [shape=circle, style=filled, width=0.8];
    
    S1 [label="s(t-1)", fillcolor=white];
    S2 [label="s(t)", fillcolor=white];
    S3 [label="s(t+1)", fillcolor=white];
    Send [label="s(T)", fillcolor=white];

    Xstart [style=invis];
    X0[label="x(0)", fillcolor=lightblue]
    X1 [label="x(t-1)", fillcolor=lightblue];
    X2 [label="x(t)", fillcolor=lightblue];
    X3 [label="x(t+1)", fillcolor=lightblue];
    Xend [label="x(T)", fillcolor=lightblue];

    Y1 [label="y(t-1)", fillcolor=salmon];
    Y2 [label="y(t)", fillcolor=salmon];
    Y3 [label="y(t+1)", fillcolor=salmon];
    Yend [label="y(T)", fillcolor=salmon];

    S1 -> X1 [label = "Îµâ‚œâ‚‹â‚"];
    S2 -> X2;
    S3 -> X3;
    Send -> Xend;

    Xstart -> X0 [label="p(xâ‚€)"];
    X0 -> S1 [label="                                       ", style=dashed];  
    X1 -> S2 [label = "p(xâ‚œ | xâ‚œâ‚‹â‚)"];
    X2 -> S3;
    X3 -> Send [label="                                       ", style=dashed];

    X1 -> Y1  [label = "Î·â‚œâ‚‹â‚"];
    X2 -> Y2 [label="p(yâ‚œ | xâ‚œ)" ];
    X3 -> Y3; 
    Xend -> Yend;

    { rank=same; S1; S2; S3; Send; }
    { rank=same; Xstart; X0; X1; X2; X3; Xend; }
    { rank=same; Y1; Y2; Y3; Yend; }
}
```



- $s(t)$: state that is modelled with a process-based model at time $t$
- $x(t)$: true hidden state at time $t$
- $y(t)$: observation at time $t$
- $p(x(t) | x(t-1))$: transition probability between the true states
- $p(y(t) | x(t))$: observation probability
- $p(xâ‚€)$: initial state of the true states
- $Îµ$: process error with distribution $Îµ_t \sim \mathcal{N}(0, Ïƒ_p)$
- $Î·$: observation error with distribution $Î·_t \sim \mathcal{N}(0, Ïƒ_o)$



## Load packages
```{julia}
using AdaptiveParticleMCMC
using AdaptiveMCMC
using CairoMakie
using Distributions
using LabelledArrays
using Statistics
using AdaptiveMCMC
using CairoMakie
using LogDensityProblems
using TransformVariables
using TransformedLogDensities
using UnPack

import MCMCChains
import PairPlots
import StatsPlots
import Random

set_theme!(
    fontsize = 18,
    Axis = (; xgridvisible = false, ygridvisible = false,
            topspinevisible = false, rightspinevisible = false),
    Legend = (; framevisible = false))
```

## Define helper functions

```{julia}
struct ModelContainerMCMC{T1, T2, T3, T4}
    y::T1
    ts::T2
    prior_distributions::T3
    transform::T4
end

function sample_prior(prob; transform = true)
    @unpack prior_distributions = prob
    
    ks = keys(prior_distributions)
    x = Float64[]
    for k in ks
        push!(x, rand(prior_distributions[k]))
    end
    Î¸ = (; zip(ks, x)...)    

    return transform ? inverse(prob.transform, Î¸) : Î¸
end

function sample_posterior(dat, prob)
    nsamples, nparameter, nchains = size(dat)
    
    vals = dat[sample(1:nsamples), :, sample(1:nchains)]
    ks = collect(keys(prob.prior_distributions))
    
    return (; zip(ks, vals)...)
end
```

# Generate data

```{julia}
Random.seed!(1234)

function generate_data(n_observations; Ïƒ_p, Ïƒ_o, r, xâ‚€)
    Îµ_t_dist = Normal(0, Ïƒ_p)
    Î·_t_dist = Normal(0, Ïƒ_o)

    ts = 1:n_observations

    s = Array{Float64}(undef, length(ts))
    s_onestep = Array{Float64}(undef, length(ts))
    x = Array{Float64}(undef, length(ts))
    y = Array{Float64}(undef, length(ts))
    K = 20
    
    
    for t in ts
        x_lastt = t == 1 ? xâ‚€ : x[t-1]
        s_lastt = t == 1 ? xâ‚€ : s[t-1]

        Îµ_t = rand(Îµ_t_dist)
        s[t] = (1 + r *(1 - s_lastt/K))  * s_lastt
        s_onestep[t] = (1 + r *(1 - x_lastt/K)) * x_lastt  
        x[t] = s_onestep[t] + Îµ_t

        Î·_t = rand(Î·_t_dist)
        y[t] = x[t] + Î·_t
    end

    (; ts, s, s_onestep, x, y, parameter = (; Ïƒ_p, Ïƒ_o, r, xâ‚€))
end

Random.seed!(123)
true_solution = generate_data(150; Ïƒ_p = 1.5, Ïƒ_o = 1.0, r = 0.1, xâ‚€ = 5.0);
```

```{julia}
let
    fig = Figure(size = (1100, 600))
    ax = Axis(fig[1, 1]; xlabel = "time", ylabel = "population size")

    scatter!(true_solution.ts, true_solution.y, color = :red, label = "observations: y")
    lines!(true_solution.ts, true_solution.x, color = :blue, label = "true hidden state: x")
    lines!(true_solution.ts, true_solution.s, color = :grey, label = "process-model state: s")

    Legend(fig[1, 2], ax)
    fig
end
```


# Naive model: ignoring the process error


## Build model
```{julia}
function no_process_error(y, ts)
    prior_dists = (;
        r = Uniform(0, 1),
        K = truncated(Normal(15.0, 10.0); lower = 0),
        Ïƒ_o = truncated(Normal(0.0, 1.0); lower = 0),
        xâ‚€ = truncated(Normal(0.0, 10.0); lower = 0))
    transform = as((r = asð•€, K = asâ„â‚Š, Ïƒ_o = asâ„â‚Š, xâ‚€ = asâ„â‚Š))

    ModelContainerMCMC(y, ts, prior_dists, transform)
end

function (prob::ModelContainerMCMC)(Î¸)
    @unpack r, K, Ïƒ_o, xâ‚€ = Î¸
    @unpack y, ts, prior_distributions = prob

    lprior = 0.0
    for k in keys(prior_distributions)
        lprior += logpdf(prior_distributions[k], Î¸[k])
    end

    llikelihood = 0.0
    if lprior > -Inf
        x = xâ‚€
        for t in ts
            x = (1 + r *(1 - x/K))* x  
            llikelihood += logpdf(Normal(x, Ïƒ_o), y[t])
        end
    end

    return llikelihood + lprior
end

problem_no_process_error = no_process_error(true_solution.y, true_solution.ts);
â„“_no_process_error = TransformedLogDensity(problem_no_process_error.transform, problem_no_process_error)
lposterior_no_process_error(x) = LogDensityProblems.logdensity(â„“_no_process_error, x)

# check that we can sample from prior and calculate the log posterior
lposterior_no_process_error(sample_prior(problem_no_process_error))
```

## Run MCMC
```{julia}
post_no_process_error = let
    nsamples = 100_000; L = 1
    nchains = 4

    post_objs = []
    for i in 1:nchains
        raw_post_chain = adaptive_rwm(sample_prior(problem_no_process_error), 
            lposterior_no_process_error, nsamples; L, b = nsamples Ã· 2, thin = 100);

        post_chain = mapslices(x -> collect(transform(problem_no_process_error.transform, x)),
                            raw_post_chain.X, dims = 1)
        push!(post_objs, post_chain')
    end
    cat(post_objs..., dims = 3)
end;
```

## Analyse results
```{julia}
chn_no_process_error = MCMCChains.Chains(post_no_process_error, 
                                         collect(keys(problem_no_process_error.prior_distributions)))
```

```{julia}
StatsPlots.plot(chn_no_process_error)
```

```{julia}
PairPlots.pairplot(chn_no_process_error) # PairPlots.Truth(true_solution.parameter)
```

## Retrodiction

```{julia}
function retrodict_no_process_error(dat, prob)
    @unpack r, K, xâ‚€ = sample_posterior(dat, prob)
    x = xâ‚€
    x_retro = Array{Float64}(undef, length(true_solution.ts))
    for t in true_solution.ts
        x = (1 + r *(1 - x/K))* x  
        x_retro[t] = x  
    end
    x_retro
end

let
    fig = Figure(size = (1100, 600))
    ax = Axis(fig[1, 1]; xlabel = "time", ylabel = "population size")

    scatter!(true_solution.ts, true_solution.y, color = :red, label = "observations: y")
    lines!(true_solution.ts, true_solution.x, color = :blue, label = "true hidden state: x")
    lines!(true_solution.ts, true_solution.s, color = :grey, label = "process-model state: s")
    
    for i in 1:100
        x_pred = retrodict_no_process_error(post_no_process_error, problem_no_process_error)
        lines!(true_solution.ts, x_pred, color = :green, alpha = 0.1, 
               label = i == 1 ? "fitted (draws from posterior)" : nothing)
    end

    Legend(fig[1, 2], ax)
    fig
end
```

# Modelling the process error without explicit state space representation

## Build model

```{julia}
function model_with_process_error(y, ts)
    prior_dists = (;
        r = Uniform(0, 1),
        K = truncated(Normal(15.0, 10.0); lower = 0),
        Ïƒ_o = truncated(Normal(0.0, 1.0); lower = 0),
        Ïƒ_p = truncated(Normal(0.0, 1.0); lower = 0),
        xâ‚€ = truncated(Normal(0.0, 10.0); lower = 0))
    transform = as((r = asð•€, K = asâ„â‚Š, Ïƒ_o = asâ„â‚Š, Ïƒ_p = asâ„â‚Š, xâ‚€ = asâ„â‚Š))

    ModelContainerMCMC(y, ts, prior_dists, transform)
end

function (prob::ModelContainerMCMC)(Î¸)
    @unpack r, K, Ïƒ_o, Ïƒ_p, xâ‚€ = Î¸
    @unpack y, ts, prior_distributions = prob

    lprior = 0.0
    for k in keys(prior_distributions)
        lprior += logpdf(prior_distributions[k], Î¸[k])
    end

    llikelihood = 0.0

    if lprior > -Inf
        x = xâ‚€
        for t in ts
            x = (1 + r *(1 - x/K))* x + rand(Normal(0, Ïƒ_p))
            llikelihood += logpdf(Normal(x, Ïƒ_o), y[t])
        end
    end

    return llikelihood + lprior
end

problem_with_process_error = model_with_process_error(true_solution.y, true_solution.ts);
â„“_with_process_error = TransformedLogDensity(problem_with_process_error.transform, 
                                             problem_with_process_error)
lposterior_with_process_error(x) = LogDensityProblems.logdensity(â„“_with_process_error, x)

# check that we can sample from prior and calculate the log posterior
lposterior_with_process_error(sample_prior(problem_with_process_error))
```

## Run MCMC
```{julia}
post_with_process_error = let
    nsamples = 100_000; L = 2
    nchains = 4

    post_objs = []
    for i in 1:nchains
        raw_post_chain = adaptive_rwm(sample_prior(problem_with_process_error), 
            lposterior_with_process_error, nsamples; L, b = nsamples Ã· 2, thin = 100);

        post_chain = mapslices(x -> collect(transform(problem_with_process_error.transform, x)),
                            raw_post_chain.X, dims = 1)
        push!(post_objs, post_chain')
    end
    cat(post_objs..., dims = 3)
end;
```


## Analyse results
```{julia}
chn_with_process_error = MCMCChains.Chains(post_with_process_error, 
    collect(keys(problem_with_process_error.prior_distributions)))
```

```{julia}
StatsPlots.plot(chn_with_process_error)
```

```{julia}
PairPlots.pairplot(chn_with_process_error) # PairPlots.Truth(true_solution.parameter)
```

# Modelling the process error without explicit state space representation - One step ahead prediction

## Build model

```{julia}
function model_with_process_error(y, ts)
    prior_dists = (;
        r = Uniform(0, 1),
        K = truncated(Normal(15.0, 10.0); lower = 0),
        Ïƒ_o = truncated(Normal(0.0, 1.0); lower = 0),
        Ïƒ_p = truncated(Normal(0.0, 1.0); lower = 0),
        xâ‚€ = truncated(Normal(0.0, 10.0); lower = 0))
    transform = as((r = asð•€, K = asâ„â‚Š, Ïƒ_o = asâ„â‚Š, Ïƒ_p = asâ„â‚Š, xâ‚€ = asâ„â‚Š))

    ModelContainerMCMC(y, ts, prior_dists, transform)
end

function (prob::ModelContainerMCMC)(Î¸)
    @unpack r, K, Ïƒ_o, Ïƒ_p, xâ‚€ = Î¸
    @unpack y, ts, prior_distributions = prob

    lprior = 0.0
    for k in keys(prior_distributions)
        lprior += logpdf(prior_distributions[k], Î¸[k])
    end

    llikelihood = 0.0

    if lprior > -Inf
        for t in ts
            x = t == 1 ? xâ‚€ : y[t-1]
            x = (1 + r *(1 - x/K))* x + rand(Normal(0, Ïƒ_p))
            llikelihood += logpdf(Normal(x, Ïƒ_o), y[t])
        end
    end

    return llikelihood + lprior
end

problem_with_process_error = model_with_process_error(true_solution.y, true_solution.ts);
â„“_with_process_error = TransformedLogDensity(problem_with_process_error.transform, 
                                             problem_with_process_error)
lposterior_with_process_error(x) = LogDensityProblems.logdensity(â„“_with_process_error, x)

# check that we can sample from prior and calculate the log posterior
lposterior_with_process_error(sample_prior(problem_with_process_error))
```

## Run MCMC
```{julia}
post_with_process_error = let
    nsamples = 100_000; L = 2
    nchains = 4

    post_objs = []
    for i in 1:nchains
        raw_post_chain = adaptive_rwm(sample_prior(problem_with_process_error), 
            lposterior_with_process_error, nsamples; L, b = nsamples Ã· 2, thin = 100);

        post_chain = mapslices(x -> collect(transform(problem_with_process_error.transform, x)),
                            raw_post_chain.X, dims = 1)
        push!(post_objs, post_chain')
    end
    cat(post_objs..., dims = 3)
end;
```


## Analyse results
```{julia}
chn_with_process_error = MCMCChains.Chains(post_with_process_error, 
    collect(keys(problem_with_process_error.prior_distributions)))
```

```{julia}
StatsPlots.plot(chn_with_process_error)
```

```{julia}
PairPlots.pairplot(chn_with_process_error) # PairPlots.Truth(true_solution.parameter)
```

## Retrodiction

```{julia}

function retrodict_with_process_error(dat, prob; process_error = false)
    @unpack Ïƒ_p, r, K, xâ‚€ = sample_posterior(dat, prob)
    x = xâ‚€
    x_retro = Array{Float64}(undef, length(true_solution.ts))
    for t in true_solution.ts
        Îµ_t = process_error ? rand(Normal(0, Ïƒ_p)) : 0.0
        x = (1 + r *(1 - x/K))* x + Îµ_t
        x_retro[t] = x  
    end
    x_retro
end

let
    fig = Figure(size = (1100, 800))
    
    ax = Axis(fig[1, 1]; title = "Without process error")
    scatter!(true_solution.ts, true_solution.y, color = :red, label = "observations: y")
    lines!(true_solution.ts, true_solution.x, color = :blue, label = "true hidden state: x")
    lines!(true_solution.ts, true_solution.s, color = :grey, label = "process-model state: s")
    for i in 1:100
        x_pred = retrodict_with_process_error(post_with_process_error, problem_with_process_error)
        lines!(true_solution.ts, x_pred, color = :green, alpha = 0.1, 
               label = i == 1 ? "fitted (draws from posterior)" : nothing)
    end
    
    Axis(fig[2, 1]; xlabel = "time", title = "With process error")
    scatter!(true_solution.ts, true_solution.y, color = :red)
    lines!(true_solution.ts, true_solution.x, color = :blue)
    lines!(true_solution.ts, true_solution.s, color = :grey)
    for i in 1:100
        x_pred = retrodict_with_process_error(post_with_process_error, 
                                              problem_with_process_error; process_error = true)
        lines!(true_solution.ts, x_pred, color = :green, alpha = 0.1, 
               label = i == 1 ? "fitted (draws from posterior)" : nothing)
    end
    
    Label(fig[1:2, 0], "Population size"; rotation = pi/2)
    Legend(fig[1:2, 2], ax)
    fig
end
```

# Real State Space Model

## Build the model

```{julia}
mutable struct Particle
    s::Float64
    Particle() = new(0.0)
end

mutable struct ModelParam
    r::Float64
    K::Float64
    Ïƒ_p::Float64
    Ïƒ_o::Float64
    xâ‚€::Float64
end
struct ModelContainerPMCMC
    par::ModelParam
    y::Vector{Float64}
    ModelContainerPMCMC() = new(ModelParam(0.5, 10.0, 1.0, 1.0, 2.0), true_solution.y)
end

function transition!(x, rng, k, x_prev, scratch)
    @unpack r, K, Ïƒ_p, xâ‚€ = scratch.par
    if k == 1
        x.s = xâ‚€ + xâ‚€ * r * (1 - xâ‚€/K) + rand(rng, Normal(0, Ïƒ_p))
    else
        x.s = x_prev.s + x_prev.s * r * (1 - x_prev.s/K) + rand(rng, Normal(0, Ïƒ_p))
    end
end

function log_potential(k, x, scratch)
    logpdf(Normal(x.s, scratch.par.Ïƒ_o), scratch.y[k])
end

inv_logit(x) = exp(x)/(1+exp(x))
function set_param!(scratch, Î¸)
    scratch.par.r = inv_logit(Î¸.logit_r)
    scratch.par.K = exp(Î¸.log_K)
    scratch.par.Ïƒ_p = exp(Î¸.log_sigma_p)
    scratch.par.Ïƒ_o = exp(Î¸.log_sigma_o)
    scratch.par.xâ‚€ = exp(Î¸.log_xâ‚€)
end

function prior(theta)
    (logpdf(Normal(0.0, 2.0), theta.logit_r) +
     logpdf(Normal(0.0, 2.5), theta.log_K) +
     logpdf(Normal(-1.0, 2.0), theta.log_sigma_p) +
     logpdf(Normal(-1.0, 2.0), theta.log_sigma_o) +
     logpdf(Normal(0.0, 2.0), theta.log_xâ‚€))
end
```

## Run MCMC

```{julia}
post_pmcmc = let
    T = length(true_solution.y)
    nparticles = 100
    nsamples = 10_000
    nchains = 4

    post_objs = []
    for i in 1:nchains
        theta0 = LVector(logit_r = 0.0, log_K = 2.0, log_sigma_p = 0.0, log_sigma_o = 0.0, log_xâ‚€ = 0.0)
        state = SMCState(T, nparticles, Particle, ModelContainerPMCMC, set_param!, log_potential, transition!);

        out = adaptive_pmmh(theta0, prior, state, nsamples; thin = 1,
                        save_paths = true, b = nsamples Ã· 2);
        
        ## out.X is the hidden state, extract it for further analysis 
        
        Î¸ = deepcopy(out.Theta)
        Î¸[1, :] = inv_logit.(out.Theta[1, :])
        Î¸[2, :] = exp.(out.Theta[2, :])
        Î¸[3, :] = exp.(out.Theta[3, :])
        Î¸[4, :] = exp.(out.Theta[4, :])
        Î¸[5, :] = exp.(out.Theta[5, :])
        
        push!(post_objs, Î¸')
    end
    
    cat(post_objs..., dims = 3)
end;
```

```{julia}
chn_pmcmc = MCMCChains.Chains(post_pmcmc, collect(fieldnames(ModelParam)))
```

```{julia}
StatsPlots.plot(chn_pmcmc)
```


```{julia}
PairPlots.pairplot(chn_pmcmc, PairPlots.Truth(true_solution.parameter))
```

## Retrodiction

```{julia}
function retrodict_pmcmc(dat; process_error = false)
    r, K, Ïƒ_p, xâ‚€ = vec(Array(sample(dat, 1)))
    
    x = xâ‚€
    x_retro = Array{Float64}(undef, length(true_solution.ts))
    for t in true_solution.ts
        Îµ_t = process_error ? rand(Normal(0, Ïƒ_p)) : 0.0
        x = (1 + r *(1 - x/K))* x  + Îµ_t
        x_retro[t] = x  
    end
    x_retro
end

let
    # S = [out.X[j][i].s for i = 1:length(out.X[1]), j = 1:length(out.X)]
    # q95 = mapslices(x -> quantile(x, [0.025, 0.975]), S, dims=2)
    # q5 = mapslices(x -> quantile(x, [0.25, 0.75]), S, dims=2)
    # q_median = mapslices(median, S, dims=2)

    fig = Figure(size = (1100, 1100))
    ax1 = Axis(fig[1, 1];)

    # band!(true_solution.ts, q95[:, 1], q95[:, 2], color = (:black, 0.2), label = "95% credible interval")
    # band!(true_solution.ts, q5[:, 1], q5[:, 2], color = (:black, 0.5), label = "50% credible interval")
    # lines!(true_solution.ts, q_median[:, 1], color = :black, label = "median")

    lines!(true_solution.ts, true_solution.x, color = :blue, label = "true hidden state: x")
    lines!(true_solution.ts, true_solution.s, color = :grey, label = "process-model state: s")
    
    ax2 = Axis(fig[2, 1];)
    lines!(true_solution.ts, true_solution.x, color = :blue)
    lines!(true_solution.ts, true_solution.s, color = :grey)
    scatter!(true_solution.ts, true_solution.y, color = :red, label = "observations: y")
     
    for i in 1:100
        x_pred = retrodict_pmcmc(chn_pmcmc)
        lines!(true_solution.ts, x_pred, color = :green, alpha = 0.1, 
               label = i == 1 ? "fitted (draws from posterior)" : nothing)
    end
    
    ax3 = Axis(fig[3, 1]; xlabel = "time")
    lines!(true_solution.ts, true_solution.x, color = :blue)
    lines!(true_solution.ts, true_solution.s, color = :grey)
    scatter!(true_solution.ts, true_solution.y, color = :red, label = "observations: y")
    for i in 1:100
        x_pred = retrodict_pmcmc(chn_pmcmc; process_error = true)
        lines!(true_solution.ts, x_pred, color = :green, alpha = 0.1, 
               label = i == 1 ? "fitted (draws from posterior)" : nothing)
    end
    
    linkyaxes!(ax1, ax2, ax3)
    Legend(fig[1:3, 2], ax1)
    Label(fig[1:3, 0], "Population size"; rotation = pi/2)
    fig
end
```